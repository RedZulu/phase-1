# Die Class 1: Numeric

# I worked on this challenge by myself.

# I spent 2 hours on this challenge.

# 0. Pseudocode

# Input: A positive integer N
# Output: An N-sided die
# Steps:
=begin
	1. Create a new N-sided die where N is a positive integer.
	2. Return the number of sides of the die
	3. Roll the die and return the outcome	
=end



# 1. Initial Solution

class Die

  def initialize(sides)
	unless sides >= 1
	  raise ArgumentError.new("A die can only have a positive number of sides.")
	end
    @die_sides = sides
  end

  def sides
    return @die_sides
  end

  def roll
    return 1 + rand(@die_sides)
  end
end


# 3. Refactored Solution


# There is nothing to refacto



# 4. Reflection
=begin
	
1. What is an ArgumentError and why would you use one?

An ArgumentError is an error message generated by a method that is caused the either 
an incorrect number of arguments being input into the method or the wrong type of argument being
input into the method.

You would use one to catch 'illegal' arguments that could lead to unpredictable or non-sense output.
For example, in the Die class, a die with zero or a negative number of sides does not make any sense.
Note that a die with 1 side makes sense, but it also makes a very unintersting die (the outcome of rolling 
such a die is predictable).

2. What new Ruby methods did you implement? What challenges and successes did you have in implementing them?

I used rand(N) to generate random integers and subsequently discovered that it generates random integers 
between 0 and N-1.

3. What is a Ruby class?

A Ruby class is a collection of methods that are common to a type of object.
In particular, a Ruby class has a method for constructing new instances of the type of object.
This method is called initialize and it sets the instance variables associated with th object.
For example, we can create a new 20-sided die (called for example d20) via d20 = Die.new(20).
In this case, Die.new invokes the Die classes initialize method, then the initialize mwthod
set the instance variable @sides to 20.

4. Why would you use a Ruby class?

Ruby classes allow you to abstract the essential properties of an object and to gather these under the auspices 
of a class. For example, suppose we wanted an abstract model of an ice cream cone, then we could define a class 
called IceCreamCone with two instance variables: @cone and @scoops. Wee can define methods such as:
self.cone-type, self.scoop_flavor, self.add_sprinkles , ... etc. In particular, defining this class would safeguard 
the sanctity of the ice cream cone by not allowing you to add anchovies or powdered glass to your cone - unless you 
specifically defined class methods that would allow you to do such things.

In other words, classes give you as muchh control as you want over the behavior of objects that are instances of the class.

5. What is the difference between a local variable and an instance variable?

A local variable is a variable whose scope is confined to a method. An instance variable is a variable defined in a class 
that is visible to all objects that are instances of that class. A class variable is always denoted by @variable-name so 
that you may easily distinguish them from other variables.

6. Where can an instance variable be used?

An instance variable can be used in any method occuring in the class.
	
=end